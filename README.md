# PCE
## Run with python

### Input
Input includes two main parts: Network Topology and Connections
#### Network Topology
The Network Topology should be generated in the format of NetworkX graph. For each link, three attributes need to be assigned: cost, bandwidth and latency. The current unit of each attribute is abstract, but the unit in the Network Topology should be consistent with the unit in Connections.\
\
Currently, the graph is randomly generated by using NetworkX and all the attributes are randomly assigned based on the users setting. 
#### Connection
The connection will be a list of list stored in `/test/data/connection.json`. \
\
The format of the input connection is `[Source node, Destination node, Bandwidth required, Latency required]`.  \
Here is an example of a random connection.json:
```
[[1,10,8,20],[2,9,10,15],[15,10,6,22]]
```
There are three queries in this connection.json, the first one is `[1,10,15,20]`.\
It means this connection query is to route traffic from Node 1 to Node 10, requring a bandwith of 8 and maximum latency of 20.\
\
For testing, a random connection generator is located at `Utility/RandomConnectionGen.py`. It can randomly generate one or multiple queries in one connection.json.

### Topology Generation
Random connection generator is located at Utility/RandomConnectionGen.py. 
```
RandomConnectionGenerator(nodes, querynum, bw, latencylimit)
```
This will randomly generate one or multiple queries in one connection.json stored in `test/data/connection.json`. 

### Output
To get the optimal path and related objective value:
#### MC_Solver
For Minimizing the total path cost, do `from LoadBalancing.MC_Solver import runMC_Solver`:
```
runMC_Solver()
```
This will output a tuple of 2 elements: (Path List Dict, Total Cost).\
For example, using the previous connection.json, the output will be:
```
({1: [[1, 13], [13, 19], [19, 8], [8, 2], [2, 10]], 2: [[2, 10], [10, 9]], 3: [[15, 10]]}, 27401516.0)
```
The first element is a dict which has the connection# as key and path list as value, for the first connection, the traffic will be routed from Node 1 to Node 10, the path will be 1->13->19->8->2->10, and the total cost for applying all the three connections will be 27401516 in total.\

#### LB_Solver
For Minimizing the total path utilization, do `from LoadBalancing.LB_Utilization_Solver import runLB_UT_Solver`:
```
runLB_UT_Solver()
```
This will output a tuple of 2 elements: (Path List Dict, Total Utilization).\
Still using the previous connection.json, this time output will be:
```
({1: [[1, 14], [14, 10]], 2: [[2, 9]], 3: [[15, 10]]}, 0.08040263457045238)
```
The first element is same as in MC_Solver, but the second element will be the total utilization of all links which is around 0.08.


### Environment Setup

The network topology is generated by NetworkX and the traffic matrix computation is executed by Google OrTools Solver. 
```
pip3 install -r requirements.txt
```
Also, every data file was stored in test/data as json file. Remember to change the path according to local directory.

# Background
## Google OR-Tools
Solver in this OR-Tools is used to solve for the optimal solution. It takes in the formulation matrix with defined objective functions and relationships with RHS. 

In this project, links are set to be binary variables which means if a link is selected, the corresponding variable is 1, if a link is not selected, the variable is 0.




## Constrained Shortest Path (CSP)

Randomgraph is used to generate the topology of a network. Each link in the network will have three attributes: cost, latency and bandwidth.

Topology will be generated in .json file. Other link info files will aslo be generated for later use.

- nodes: Number of nodes in the graph
- p: Probability of link creation
- max_latency: Used for testing the heuristic sorting method. Can be set to 99999 for regular topology.
- bwlimit: Remove any link that is lower than this bwlimit. There is connectivity check before the final creation of the topology, new topology will be created if the current one is not connected.

Formualtion:

![alt text](https://github.com/yifei666/pce/blob/e65eec6f1b4886e68c26d332420f64d34ff397eb/Reference/CSP_formulation_latex.png)

## Load Balancing

Load Balancing is developed based on the CSP problem. User can input a list of queries and get the overall optimal solutions. 

Example Formualtion:

![alt text](https://github.com/yifei666/pce/blob/91f8fb82f85d5ada8714b597c5cd5ae4979ba92b/Reference/LoadBalancing_Ex.png)

## Utility and Benchmark

Other utility funcions are aslo included, such as: Dijkstra algorithms, Network connectivity check, etc.

Benchmark results are also provided. Computation time and cost difference std are being tested between solver formulation and heurtistic sorting methods( by latency and by cost).
